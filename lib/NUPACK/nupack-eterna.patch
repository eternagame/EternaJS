diff -ur -X .gitignore nupack3.0.4_stock/src/thermo/utils/CalculateEnergy.c nupack3.0.4/src/thermo/utils/CalculateEnergy.c
--- nupack3.0.4_stock/src/thermo/utils/CalculateEnergy.c	2019-11-23 17:28:53.653157300 -0500
+++ nupack3.0.4/src/thermo/utils/CalculateEnergy.c	2019-11-23 15:35:11.830525700 -0500
@@ -13,6 +13,10 @@
 
 #include "pfuncUtilsHeader.h" //contains functions and structures
 #include "DNAExternals.h"
+
+/* for AS3 */
+extern void (*eos_cb)(int index, int fe);
+
 //***********************************************************
 
 DBL_TYPE naEnergy( char *prefix, int seq[]) {
@@ -71,7 +75,6 @@
                                           possibleSymmetry, nStrands))*kB*TEMP_K;
   energy += (BIMOLECULAR + SALT_CORRECTION)*(nStrands-1);
 
-
   free( foldFile);
   free( thefold.pairs);
   free( thefold.pknots);
@@ -149,6 +152,7 @@
   energy += LOG_FUNC( (DBL_TYPE) checkSymmetry( thefold.pairs, seqlength, nicks, 
                                            possibleSymmetry, nStrands))*kB*TEMP_K;
   energy += (BIMOLECULAR + SALT_CORRECTION)*(nStrands-1);
+  if (eos_cb && (nStrands > 1)) (*eos_cb)(-2, floor(.5 + (BIMOLECULAR + SALT_CORRECTION)*(nStrands-1)*100.));
   
   free( thefold.pairs);
   free( thefold.pknots);
@@ -168,14 +172,15 @@
   
   int pairsFromParens[ MAXSEQLENGTH];
   
-  
+
   thefold->seqlength = seqlength;
   thefold->seq = seq;
   
   pairsFromParens[0] = -5; 
-  if( parens != NULL) 
+  if( parens != NULL) {
     getStructureFromParens( parens, pairsFromParens,  
                            thefold->seqlength);
+  }
   
   thefold->pairs = 
     (int*) calloc( thefold->seqlength+1, sizeof(int));
@@ -195,14 +200,22 @@
     thefold->pairs[init] = -1;
     thefold->pknots[init] = -1;
   }
-  
+
+#if 0  
   for( init = 0; init <= thefold->seqlength - 1; init++) {
     if( parens != NULL) 
       thefold->pairs[init] = pairsFromParens[init];
     else
       thefold->pairs[init] = thepairs[init];
   }
-  
+#else
+  // it seems that the version of LLVM included in Alchemy
+  // attempts to optimize the loop above by combining it
+  // with the one below. And although only safe optimizations
+  // are allowed, the module messes up something...
+  // Temporary solution: replace the loop
+  memmove(thefold->pairs, (parens != NULL) ? pairsFromParens : thepairs, thefold->seqlength * sizeof(int));
+#endif
   
   //the following pknot finding routine should be optimized
   for( init = 0; init <= thefold->seqlength-1; init++) {
@@ -220,7 +233,6 @@
       
     }
   }
-  
 }
 
 
diff -ur -X .gitignore nupack3.0.4_stock/src/thermo/utils/GetEnergy.c nupack3.0.4/src/thermo/utils/GetEnergy.c
--- nupack3.0.4_stock/src/thermo/utils/GetEnergy.c	2019-11-23 17:28:53.656141200 -0500
+++ nupack3.0.4/src/thermo/utils/GetEnergy.c	2019-11-23 15:35:11.833542600 -0500
@@ -14,6 +14,8 @@
 #include "pfuncUtilsHeader.h"
 #include "DNAExternals.h"
 
+/* for AS3 */
+void (*eos_cb)(int index, int fe) = NULL;
 
 /* ******************************** */
 DBL_TYPE GetEnergy( fold *thefold) {
@@ -33,6 +35,8 @@
   
   int j;
   DBL_TYPE bp_penalty;
+  DBL_TYPE local_e = 0.0;
+  DBL_TYPE contrib;
   
   j = stop; 
   while( j >= start) {
@@ -65,10 +69,12 @@
         bp_penalty = AT_PENALTY;
       }
       //EnergyFb( d, j, thefold);
-      energy +=
-        EnergyFb( d, j, thefold) + 
+      contrib = 
         DangleEnergyWithPairs( j+1, stop, thefold) +
         bp_penalty;
+      energy +=
+        EnergyFb( d, j, thefold) + contrib;
+      local_e += contrib;
       
       j = d-1;
       stop = j;
@@ -79,8 +85,11 @@
   }
   
   
-  energy += DangleEnergyWithPairs( start, stop, 
+  contrib = DangleEnergyWithPairs( start, stop, 
                                   thefold);
+  energy += contrib;
+  local_e += contrib;
+  if (eos_cb) (*eos_cb)(-1, floor(.5 + local_e * 100.));
   /*  
   energy += DangleEnergy( start, stop, 
   thefold->seq, thefold->seqlength);
@@ -190,14 +199,17 @@
   if( nNicks == 0) {
     if( nPairs == 1) { //hairpin
       energy = HairpinEnergy( start, firstStop, thefold->seq);			
+      if (eos_cb) (*eos_cb)(start, floor(.5 + energy * 100.));
       //return energy;
     }
     else if( nPairs == 2) { //interior loop
-      energy = InteriorEnergy( start, firstStop, pairs[2], pairs[3], thefold->seq)
-        + EnergyFb( pairs[2], pairs[3], thefold);
+      DBL_TYPE il_en = InteriorEnergy( start, firstStop, pairs[2], pairs[3], thefold->seq);
+      energy = il_en + EnergyFb( pairs[2], pairs[3], thefold);
+      if (eos_cb) (*eos_cb)(start, floor(.5 + il_en * 100.));
       //return energy;
     }
     else if( nPairs >= 3) { //multiloop
+      DBL_TYPE sub_en = 0.0;
       energy = ALPHA_1 + ALPHA_2 + ALPHA_3 * (pairs[1]-pairs[3]-1) + 
         DangleEnergyWithPairs(pairs[3]+1, pairs[1]-1, thefold);
       
@@ -210,11 +222,14 @@
       
       for( i = 1; i < nPairs; i++) {
         if( thefold->pknots[ pairs[2*i]] == -1) { //not a pseudoknot
+          DBL_TYPE fb_en;
           if( thefold->seq[ pairs[2*i]] != BASE_C && thefold->seq[ pairs[2*i+1]] != BASE_C) {
             bp_penalty += AT_PENALTY;
           }
           
-          energy += EnergyFb( pairs[2*i], pairs[ 2*i+1], thefold) + ALPHA_2;
+          fb_en = EnergyFb( pairs[2*i], pairs[ 2*i+1], thefold) + ALPHA_2;
+          energy += fb_en;
+          sub_en += fb_en;
         }
         else { //a pseudoknot
           p1 = pairs[2*i];
@@ -241,6 +256,7 @@
           DangleEnergyWithPairs( pairs[ p2]+1, pairs[p1]-1, thefold);
       }
       energy += bp_penalty;
+      if (eos_cb) (*eos_cb)(start, floor(.5 + (energy - sub_en) * 100.));
     }
     else {
       printf("Error in calculation of EnergyFb! %d\n", nPairs);
@@ -248,6 +264,7 @@
     }
   }
   else if( nNicks == 1) { //nNicks
+    DBL_TYPE sub_en = 0.0;
     if( thefold->seq[ pairs[0]] != BASE_C && thefold->seq[ pairs[1]] != BASE_C) {
       bp_penalty = AT_PENALTY;
     }
@@ -261,11 +278,14 @@
       energy = DangleEnergyWithPairs(pairs[3]+1, pairs[1]-1, thefold);
       
       for( i = 1; i < nPairs; i++) {
+        DBL_TYPE fb_en;
         if( thefold->seq[ pairs[2*i]] != BASE_C && thefold->seq[ pairs[2*i+1]] != BASE_C) {
           bp_penalty += AT_PENALTY;
         }
         
-        energy += EnergyFb( pairs[2*i], pairs[ 2*i+1], thefold);
+        fb_en = EnergyFb( pairs[2*i], pairs[ 2*i+1], thefold);
+        energy += fb_en;
+        sub_en += fb_en;
         
         p1 = 2*i;
         if( i != nPairs - 1) p2 = 2*i+3;
@@ -277,6 +297,7 @@
       //return energy;
     }
     
+    if (eos_cb) (*eos_cb)(start, floor(.5 + (energy - sub_en) * 100.));
   }
   
   //#ifdef SHOWFB
diff -ur -X .gitignore nupack3.0.4_stock/src/thermo/utils/backtrack.c nupack3.0.4/src/thermo/utils/backtrack.c
--- nupack3.0.4_stock/src/thermo/utils/backtrack.c	2019-11-23 17:28:53.671101500 -0500
+++ nupack3.0.4/src/thermo/utils/backtrack.c	2019-11-23 15:35:11.837506500 -0500
@@ -79,7 +79,8 @@
   }
 
   for( d = i; d <= j - 1; d++) {
-   if( etaN[ EtaNIndex(d-0.5, d-0.5, seqlength)][0] == 0 || d == i ) {
+   //if( etaN[ EtaNIndex(d-0.5, d-0.5, seqlength)][0] == 0 || d == i ) {
+   if( etaN[ pf_index(IDX(d-1), IDX(d-1), seqlength)][0] == 0 || d == i ) {
      
      pf_id1 = pf_index(i,d-1,seqlength);
      
@@ -113,10 +114,12 @@
      extraTerms = DangleEnergy( i, d-1, seq, seqlength) +
        (ALPHA_3)*(d-i);
 
-     if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0) { 
+     //if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0) { 
+     if( etaN[ pf_index( IDX(d-1), IDX(d-1), seqlength)][0] == 0) { 
        //otherwise Qm not possible
 
-       if( etaN[ EtaNIndex(i+0.5, d-0.5, seqlength)][0] == 0 ) {
+       //if( etaN[ EtaNIndex(i+0.5, d-0.5, seqlength)][0] == 0 ) {
+       if( etaN[ pf_index(IDX(i), IDX(d-1), seqlength)][0] == 0 ) {
          tempMin = Fms[ pf_index( d, j, seqlength)] + extraTerms;
          if( strcmp( type, "Fm") == 0 && WithinEps( Fm[ pf_ij], tempMin, 
              ENERGY_TOLERANCE, allowableError)) {
@@ -200,12 +203,13 @@
                 const int onlyOne) {
   
   int d; //base pair is i,d
-  DBL_TYPE bp_penalty = 0.0;
+  DBL_TYPE bp_penalty;
   int pf_ij = pf_index( i, j, seqlength);
   
   DBL_TYPE extraTerms;
   int nNicks;
-  int index_ij = EtaNIndex( i+0.5, j-0.5, seqlength);
+  //int index_ij = EtaNIndex( i+0.5, j-0.5, seqlength);
+  int index_ij = pf_index( IDX(i), IDX(j-1), seqlength);
   int start;
   DBL_TYPE tempMin;
   
@@ -240,11 +244,11 @@
   }
 
   for( d = start; d <= j; d++) {
-    bp_penalty = 0.0;
     
     if( CanPair( seq[i], seq[ d]) == TRUE &&
        ( seq[i]) + ( seq[d]) == 5) {
 
+         bp_penalty = 0.0;
          if( seq[i] != BASE_C && seq[d] != BASE_C) {
            bp_penalty = AT_PENALTY;
          }
@@ -413,7 +417,7 @@
   // Decomposes the region inside pair i,j into multiloops, i.e.
   // and excludes the possibility of "top level" nicks
 
-  DBL_TYPE bp_penalty = 0.0;
+  DBL_TYPE bp_penalty;
   DBL_TYPE extraTerms;
   DBL_TYPE tempMin;
   int pf_ij = pf_index(i, j, seqlength);
@@ -439,11 +443,12 @@
 
   if( ( seq[i]) + ( seq[j]) == 5) {
     for( d = i+3; d <= j - 2; d++) {
-      //reset loop parameters
-      bp_penalty = 0.0;
 
-      if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0 ) {
+      //if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0 ) {
+      if( etaN[ pf_index( IDX(d-1), IDX(d-1), seqlength)][0] == 0 ) {
         
+        //reset loop parameters
+        bp_penalty = 0.0;
         if( seq[i] != BASE_C  && seq[j] != BASE_C) {
           bp_penalty += AT_PENALTY;
         }
@@ -494,7 +499,7 @@
                         const int onlyOne) {
 
   DBL_TYPE tempMin;
-  DBL_TYPE bp_penalty = 0.0;
+  DBL_TYPE bp_penalty;
   int multiNick = -1;
   int index_ij;
   int leftIndex;
@@ -523,13 +528,16 @@
   //PrintS( &rootStr);
   
   
-  index_ij = EtaNIndex(i+0.5, j-0.5, seqlength);
+  //index_ij = EtaNIndex(i+0.5, j-0.5, seqlength);
+  index_ij = pf_index(IDX(i), IDX(j-1), seqlength);
   
   iNicked = jNicked = FALSE;
-  if( etaN[ EtaNIndex(j-0.5, j-0.5, seqlength)][0] != 0) {
+  //if( etaN[ EtaNIndex(j-0.5, j-0.5, seqlength)][0] != 0) {
+  if( etaN[ pf_index(IDX(j-1), IDX(j-1), seqlength)][0] != 0) {
     jNicked = TRUE;
   }
-  if( etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] != 0) {
+  //if( etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] != 0) {
+  if( etaN[ pf_index(IDX(i), IDX(i), seqlength)][0] != 0) {
     iNicked = TRUE;
   }
 
@@ -631,8 +639,10 @@
   for( L = j-i-2; L >= j-i-2-maxILoopSize[pf_ij]; L--) { 
     for( d = i+1; d <= j-L-1; d++) {
       e = d+L;
-      if( CanPair( seq[d], seq[e]) && etaN[ EtaNIndex( i+0.5, d-0.5, seqlength)][0] == 0 &&
-         etaN[ EtaNIndex( e+0.5, j-0.5, seqlength)][0] == 0) {
+      //if( CanPair( seq[d], seq[e]) && etaN[ EtaNIndex( i+0.5, d-0.5, seqlength)][0] == 0 &&
+         //etaN[ EtaNIndex( e+0.5, j-0.5, seqlength)][0] == 0) {
+      if( CanPair( seq[d], seq[e]) && etaN[ pf_index( IDX(i), IDX(d-1), seqlength)][0] == 0 &&
+         etaN[ pf_index( IDX(e), IDX(j-1), seqlength)][0] == 0) {
         energy = InteriorEnergy( i,j,d,e,seq) + Fb[ pf_index(d,e,seqlength)];
         if( WithinEps( Fb[ pf_ij], energy, ENERGY_TOLERANCE, allowableError)) {
 
diff -ur -X .gitignore nupack3.0.4_stock/src/thermo/utils/ene.c nupack3.0.4/src/thermo/utils/ene.c
--- nupack3.0.4_stock/src/thermo/utils/ene.c	2019-11-23 17:28:53.683068800 -0500
+++ nupack3.0.4/src/thermo/utils/ene.c	2019-11-23 15:35:11.841789000 -0500
@@ -71,10 +71,10 @@
 
   extern DBL_TYPE MMEnergiesIL[];
   int cp_shift;
-  DBL_TYPE energy = 0.0;
+  DBL_TYPE energy;
 
   cp_shift = GetMismatchShift( a, b );
-  energy = MMEnergiesIL[ (4*(( x) - 1) + (( y) - 1) )*6 + cp_shift];
+  energy = MMEnergiesIL[ (((( x) - 1)<<2) + (( y) - 1) )*6 + cp_shift];
 
   return energy;
 }
@@ -133,11 +133,11 @@
       energy += AT_PENALTY;
     }
 
-    triloopnumber = 256*(( seq[i]) - 1) +
-      64*(( seq[i + 1]) - 1) +
-      16*(( seq[i + 2]) - 1) +
-      4*( ( seq[j - 1]) - 1) +
-      1*( ( seq[j]) - 1);
+    triloopnumber = ((( seq[i]) - 1)<<8) +
+      ((( seq[i + 1]) - 1)<<6) +
+      ((( seq[i + 2]) - 1)<<4) +
+      (( ( seq[j - 1]) - 1)<<2) +
+      ( ( seq[j]) - 1);
 
     // 0 mismatch energy for triloops
     energy += triloop_energy[ triloopnumber];
@@ -149,18 +149,18 @@
   }
   else if (size == 4) {
 
-    tloopnumber = 1024*(( seq[i]) - 1) +
-      256*(( seq[i + 1]) - 1) +
-      64*( ( seq[i + 2]) - 1) +
-      16*( ( seq[j - 2]) - 1) +
-      4*(  ( seq[j - 1]) - 1) +
-      1*(  ( seq[j])- 1);
+    tloopnumber = ((( seq[i]) - 1)<<10) +
+      ((( seq[i + 1]) - 1)<<8) +
+      (( ( seq[i + 2]) - 1)<<6) +
+      (( ( seq[j - 2]) - 1)<<4) +
+      ((  ( seq[j - 1]) - 1)<<2) +
+      (  ( seq[j])- 1);
     energy +=  tloop_energy[ tloopnumber];
 
     //Next do mismatches.
     cp_shift = GetMismatchShift( seq[i], seq[j]);
 
-    energy += MMEnergiesHP[(4*(( seq[i + 1]) - 1) +
+    energy += MMEnergiesHP[(((( seq[i + 1]) - 1)<<2) +
                             (( seq[j - 1]) - 1) )*6
                            + cp_shift];
     //Poly-C loop
@@ -173,7 +173,7 @@
     // Calculate mismatch
     cp_shift = GetMismatchShift( seq[i], seq[j]);
 
-    energy += MMEnergiesHP[(4*(( seq[i + 1]) - 1) +
+    energy += MMEnergiesHP[(((( seq[i + 1]) - 1)<<2) +
                             (( seq[j - 1]) - 1) )*6
                            + cp_shift];
 
@@ -192,6 +192,8 @@
   return InteriorEnergyFull( i, j, h, m, seq, TRUE);
 }
 
+DBL_TYPE (*binding_site_cb)(int i, int j, int h, int m) = NULL;
+
 DBL_TYPE InteriorEnergyFull( int i, int j, int h, int m, int seq[],
                              int calcIJ) {
 
@@ -276,18 +278,18 @@
         cp_shift = GetMismatchShift( seq[i], seq[j]);
         ip_shift = GetMismatchShift( seq[h], seq[m]);
         if (cp_shift==-1 || ip_shift==-1) return 0.0; //Wrongly called 
-        energy += IL_SInt2[ 96*cp_shift + 16*ip_shift +
-                           4*(( seq[i+1]) - 1) +
+        energy += IL_SInt2[ 96*cp_shift + (ip_shift<<4) +
+                           ((( seq[i+1]) - 1)<<2) +
                            (( seq[ j -1]) - 1) ];
       }
       else if( asymmetry == 0 && size == 4) {
         cp_shift = GetMismatchShift( seq[i], seq[j]);
         ip_shift = GetMismatchShift( seq[h], seq[m]);
         if (cp_shift==-1 || ip_shift==-1) return 0.0; //Wrongly called 
-        energy += IL_SInt4[ cp_shift*256*6 +  ip_shift*256 +
-                           (4*(( seq[ i+1])  - 1) +
-                            ( seq[ j - 1])   - 1)*16 +
-                           (4*( ( seq[ i+2]) - 1) +
+        energy += IL_SInt4[ cp_shift*256*6 +  (ip_shift<<8) +
+                           ((((( seq[ i+1])  - 1)<<2) +
+                            ( seq[ j - 1])   - 1)<<4) +
+                           ((( ( seq[ i+2]) - 1)<<2) +
                             ( seq[ j - 2])   - 1) ];
       }
       else if( asymmetry == 1 && L1 == 1) {
@@ -297,7 +299,7 @@
         energy += IL_AsInt1x2[ cp_shift*4*24*4 +
                               (( seq[ j - 2]) - 1)*24*4 +
                               (( seq[ i + 1]) - 1)*24 +
-                              4*ip_shift +
+                              (ip_shift<<2) +
                               ((( seq[ j - 1]) - 1) % 4) ];
       }
       else if( asymmetry == 1 && L1 == 2) {
@@ -310,7 +312,7 @@
         energy += IL_AsInt1x2[ ip_shift*4*24*4 +
                               (( seq[i + 1]) - 1)*24*4 +
                               (( seq[j - 1]) - 1)*24 +
-                              4*cp_shift +
+                              (cp_shift<<2) +
                               ((( seq[i + 2]) - 1) % 4) ];
       }
       else {
@@ -324,6 +326,9 @@
     exit(1);
   }
 
+  if (binding_site_cb != NULL)
+    energy += (*binding_site_cb)(i, j, h, m);
+
   return energy;
 }
 
@@ -373,7 +378,7 @@
     }
 #endif
     if( j != -1)
-      dangle3 = dangle_energy[ 24 + dangle_shift*4 + ( seq[ j]) - 1];
+      dangle3 = dangle_energy[ 24 + (dangle_shift<<2) + ( seq[ j]) - 1];
   }
 
   if( i == 0) {
@@ -391,7 +396,7 @@
     }
 #endif
     if( i != seqlength)
-      dangle5 = dangle_energy[ dangle_shift*4 + ( seq[ i]) - 1];
+      dangle5 = dangle_energy[ (dangle_shift<<2) + ( seq[ i]) - 1];
   }
 
   if( DANGLETYPE != 2 && j == i - 1) {
@@ -461,7 +466,7 @@
       //exit(1);
     }
 #endif
-    dangle3 = dangle_energy[ 24 + dangle_shift*4 + ( seq[ j]) - 1];
+    dangle3 = dangle_energy[ 24 + (dangle_shift<<2) + ( seq[ j]) - 1];
   }
 
   if( i == 0) {
@@ -479,7 +484,7 @@
     }
 #endif
 
-    dangle5 = dangle_energy[ dangle_shift*4 +
+    dangle5 = dangle_energy[ (dangle_shift<<2) +
                             ( seq[ i]) - 1];
   }
 
@@ -538,7 +543,7 @@
       exit(-1);
     }
     dangle_shift = 3 - pt;
-    dangle3 = dangle_energy[ 24 + dangle_shift*4 +
+    dangle3 = dangle_energy[ 24 + (dangle_shift<<2) +
                             ( seq[ j]) - 1];
   }
 
@@ -553,7 +558,7 @@
     }
 
     dangle_shift = pt;
-    dangle5 = dangle_energy[ dangle_shift*4 +
+    dangle5 = dangle_energy[ (dangle_shift<<2) +
                             ( seq[ i]) - 1];
   }
 
@@ -586,7 +591,7 @@
   }
   else {
     dangle_shift = 3 - GetPairType( seq[ j + 1]);
-    dangle3 = dangle_energy[ 24 + dangle_shift*4 + 
+    dangle3 = dangle_energy[ 24 + (dangle_shift<<2) + 
                             seq[ j] - 1];
   }
   
@@ -595,7 +600,7 @@
   }
   else {
     dangle_shift = GetPairType( seq[i-1]);
-    dangle5 = dangle_energy[ dangle_shift*4 + 
+    dangle5 = dangle_energy[ (dangle_shift<<2) + 
                             seq[ i] - 1];
   }
   
@@ -659,10 +664,12 @@
   nick = -5;
 
   if( i != 0) { //if j == seqlength -1, this is still OK
-    nIndex = EtaNIndex( i-0.5, j+0.5, seqlength);
+    //nIndex = EtaNIndex( i-0.5, j+0.5, seqlength);
+    nIndex = pf_index( IDX(i-1), IDX(j), seqlength);
   }
   else {
-    nIndex = EtaNIndex( i+0.5, j+0.5, seqlength);
+    //nIndex = EtaNIndex( i+0.5, j+0.5, seqlength);
+    nIndex = pf_index( IDX(i), IDX(j), seqlength);
   }
 
   if( etaN[ nIndex][0] >= 2 ||
@@ -697,7 +704,7 @@
       dangle_shift = GetMismatchShift( seq[i-1], seq[j+1]);
     }
 
-    dangle3 = dangle_energy[ 24 + dangle_shift*4 +
+    dangle3 = dangle_energy[ 24 + (dangle_shift<<2) +
                             ( seq[ j]) - 1];
   }
 
@@ -712,7 +719,7 @@
       dangle_shift = GetMismatchShift( seq[i-1], seq[j+1]);
     }
 
-    dangle5 = dangle_energy[ dangle_shift*4 +
+    dangle5 = dangle_energy[ (dangle_shift<<2) +
                             ( seq[ i]) - 1];
   }
 
@@ -740,7 +747,8 @@
 DBL_TYPE NickedEmptyQ( int i, int j, const int nicks[], int seq[],
                       int seqlength, int **etaN) {
 
-  if( j <= i || etaN[ EtaNIndex( i+0.5, j-0.5, seqlength)][0] == 0) {
+  //if( j <= i || etaN[ EtaNIndex( i+0.5, j-0.5, seqlength)][0] == 0) {
+  if( j <= i || etaN[ pf_index( IDX(i), IDX(j-1), seqlength)][0] == 0) {
     return EXP_FUNC( -1*NickDangle(i, j, nicks, etaN,
                               FALSE, seq, seqlength)
                 /(kB*TEMP_K));
@@ -754,13 +762,14 @@
 /* ******** */
 DBL_TYPE NickedEmptyF( int i, int j, const int nicks[], int seq[],
                        int seqlength, int **etaN) {
-  DBL_TYPE result = NAD_INFINITY;
+  DBL_TYPE result;
 
-  if( j <= i || etaN[ EtaNIndex( i+0.5, j-0.5, seqlength)][0] == 0) {
-    result = NickDangle(i, j, nicks, etaN, FALSE, seq, seqlength);
+  //if( j <= i || etaN[ EtaNIndex( i+0.5, j-0.5, seqlength)][0] == 0) {
+  if( j <= i || etaN[ pf_index( IDX(i), IDX(j-1), seqlength)][0] == 0) {
+    return NickDangle(i, j, nicks, etaN, FALSE, seq, seqlength);
   }
 
-  return result;
+  return NAD_INFINITY;
 }
 
 /* ********* */
@@ -774,7 +783,11 @@
   return EXP_FUNC( - energy/( kB*TEMP_K));
 }
 
-DBL_TYPE sizeLog(int size){
+DBL_TYPE sizeLog(int size) {
+  return (1.75 * kB) * TEMP_K * LOG_FUNC(size / 30.0);
+}
+
+DBL_TYPE sizeLogCache(int size){
   static DBL_TYPE *slCache[MAXSTRANDS], *edc, tc;
   static int CacheInd=-1, nCaches=0;
   static DBL_TYPE TCache[MAXSTRANDS];
diff -ur -X .gitignore nupack3.0.4_stock/src/thermo/utils/init.c nupack3.0.4/src/thermo/utils/init.c
--- nupack3.0.4_stock/src/thermo/utils/init.c	2019-11-23 17:28:53.686061200 -0500
+++ nupack3.0.4/src/thermo/utils/init.c	2019-11-23 15:35:11.844512400 -0500
@@ -418,16 +418,18 @@
   // Allocate and deallocate Fx matrices
   
   int i;
-  int maxStorage;
+  static int maxStorage = 0;
+  static DBL_TYPE* Fc = NULL;
   DBL_TYPE *temp;
   
-  maxStorage = (seqlength - len)*(len - 1);
-  for( i = len+1; i <= len + 2; i++) {
-    maxStorage = MAX( maxStorage, ( seqlength - i)*(i - 1) );
-  }
-  
-  
   if( len == 11) { //first use of these matrices
+    maxStorage = (seqlength - len)*(len - 1);
+    for( i = len+1; i < seqlength; i++) {
+      maxStorage = MAX( maxStorage, ( seqlength - i)*(i - 1) );
+    }
+    
+    if (Fc) free(Fc);
+    Fc = (DBL_TYPE *) calloc( maxStorage, sizeof( DBL_TYPE));
     *Fx = (DBL_TYPE *) calloc( maxStorage, sizeof( DBL_TYPE));
     *Fx_1 = 
       (DBL_TYPE *) calloc( maxStorage, sizeof( DBL_TYPE));
@@ -438,9 +440,13 @@
       fprintf(stderr, "Error in Fx, Fx_1, Fx_2 allocation\n");
     }
     
-    for( i = 0; i < maxStorage; i++) 
-      (*Fx)[i] = (*Fx_1)[i] = (*Fx_2)[i] = NAD_INFINITY;
-    
+    for( i = 0; i < maxStorage; i++)
+      Fc[i] = NAD_INFINITY;
+      // (*Fx)[i] = (*Fx_1)[i] = (*Fx_2)[i] = NAD_INFINITY;
+    
+    memmove(*Fx, Fc, maxStorage * sizeof(DBL_TYPE));
+    memmove(*Fx_1, Fc, maxStorage * sizeof(DBL_TYPE));
+    memmove(*Fx_2, Fc, maxStorage * sizeof(DBL_TYPE));
   }
   
   else if( len > 11) {
@@ -448,6 +454,9 @@
     temp = *Fx;
     *Fx = *Fx_1;
     *Fx_1 = *Fx_2;
+    *Fx_2 = temp;
+    memmove(*Fx_2, Fc, maxStorage * sizeof(DBL_TYPE));
+/*
     free( temp);
     *Fx_2 =
       (DBL_TYPE *) calloc( maxStorage, sizeof( DBL_TYPE));
@@ -457,6 +466,7 @@
     }
     for( i = 0; i < maxStorage; i++) 
       (*Fx_2)[i] = NAD_INFINITY;
+*/
     
   }
 }
@@ -1854,11 +1864,15 @@
   
   int i,j,k, nick;
   int indexE;
+
+  int arraySize = seqlength*(seqlength+1)/2 + (seqlength+1);
+  int* blk = (int*) malloc( arraySize*2*sizeof( int));
   
   for( i = 0; i <= seqlength-1; i++) {
     for( j = i-1; j <= seqlength-1; j++) {
       indexE = pf_index( i, j, seqlength);
-      etaN[ indexE] = (int *) malloc( 2*sizeof( int));
+      //etaN[ indexE] = (int *) malloc( 2*sizeof( int));
+      etaN[ indexE] = blk + 2*indexE;
       etaN[ indexE][0] = 0;
       etaN[ indexE][1] = -1;
       
diff -ur -X .gitignore nupack3.0.4_stock/src/thermo/utils/mfeUtils.c nupack3.0.4/src/thermo/utils/mfeUtils.c
--- nupack3.0.4_stock/src/thermo/utils/mfeUtils.c	2019-11-23 17:28:53.658135200 -0500
+++ nupack3.0.4/src/thermo/utils/mfeUtils.c	2019-11-23 15:35:11.847511100 -0500
@@ -29,6 +29,7 @@
 #include <stdlib.h>
 #include <math.h>
 #include <time.h>
+#include <sys/time.h>
 
 #include "pfuncUtilsHeader.h"
 
@@ -37,6 +38,7 @@
 int containsPk;
 /* End Global Variables */
 
+void TraceJS(char* text);
 
 /* ****************************** */
 // This is the main MFE calculator.  Actually finds all suboptimal folds
@@ -52,31 +54,31 @@
   DBL_TYPE result;
   int seqlength;
 
-  DBL_TYPE *F = NULL;
-  DBL_TYPE *Fb = NULL;
-  DBL_TYPE *Fm = NULL;
+  static DBL_TYPE *F = NULL;
+  static DBL_TYPE *Fb = NULL;
+  static DBL_TYPE *Fm = NULL;
 
   //N^3
-  DBL_TYPE *Fx = NULL;
-  DBL_TYPE *Fx_1 = NULL;
-  DBL_TYPE *Fx_2 = NULL;
-  DBL_TYPE *Fs = NULL;
-  DBL_TYPE *Fms = NULL;
+  static DBL_TYPE *Fx = NULL;
+  static DBL_TYPE *Fx_1 = NULL;
+  static DBL_TYPE *Fx_2 = NULL;
+  static DBL_TYPE *Fs = NULL;
+  static DBL_TYPE *Fms = NULL;
 
   //PKNOTS
-  DBL_TYPE *Fp = NULL;
-  DBL_TYPE *Fz = NULL;  //O(N^2)
-  DBL_TYPE *Fg = NULL; //O(N^4)
+  static DBL_TYPE *Fp = NULL;
+  static DBL_TYPE *Fz = NULL;  //O(N^2)
+  static DBL_TYPE *Fg = NULL; //O(N^4)
 
   //N^5
-  DBL_TYPE *FgIx = NULL;
-  DBL_TYPE *FgIx_1 = NULL;
-  DBL_TYPE *FgIx_2 = NULL;
-  DBL_TYPE *Fgls = NULL;
-  DBL_TYPE *Fgrs = NULL;
+  static DBL_TYPE *FgIx = NULL;
+  static DBL_TYPE *FgIx_1 = NULL;
+  static DBL_TYPE *FgIx_2 = NULL;
+  static DBL_TYPE *Fgls = NULL;
+  static DBL_TYPE *Fgrs = NULL;
 
-  DBL_TYPE *Fgl = NULL;
-  DBL_TYPE *Fgr = NULL; //O(N^4) space
+  static DBL_TYPE *Fgl = NULL;
+  static DBL_TYPE *Fgr = NULL; //O(N^4) space
 
   /*  F-type matrices are dynamically allocated matrices that
   contain minimum energies restricted to a subsequence of the
@@ -95,6 +97,7 @@
   DBL_TYPE tempMin;
 
   extern long int maxGapIndex;
+  static long int last_maxGapIndex;
   short *possiblePairs;
 
   int nicks[ MAXSTRANDS];  //the entries must be strictly increasing
@@ -102,6 +105,7 @@
 
   int **etaN;
   int arraySize;
+  static int last_arraySize = 0;
   int nStrands;
   int *seq;
   int *foldparens;
@@ -115,6 +119,8 @@
   int symmetryOfStruct = 1; // Must be initialized
   int *thepairs;  
 
+  struct timeval start;
+  gettimeofday(&start, NULL);
 
   //assign global variables
   TEMP_K = temperature + ZERO_C_IN_KELVIN;
@@ -156,12 +162,21 @@
   if( complexity >= 5) //pseudoknotted
    initMfe( seqlength);
 
+#define MATRIX_INIT(M,S,AS,T) do { \
+  if (S > AS || M == NULL) { \
+    if (M) free(M); \
+    InitLDoublesMatrix(&M, S, T); \
+  } \
+} while(0)
 
   arraySize = seqlength*(seqlength+1)/2 + (seqlength+1);
   // Allocate and Initialize Matrices
-  InitLDoublesMatrix( &F, arraySize, "F");
-  InitLDoublesMatrix( &Fb, arraySize, "Fb");
-  InitLDoublesMatrix( &Fm, arraySize, "Fm");
+  MATRIX_INIT(F, arraySize, last_arraySize, "F");
+  //InitLDoublesMatrix( &F, arraySize, "F");
+  MATRIX_INIT(Fb, arraySize, last_arraySize, "Fb");
+  //InitLDoublesMatrix( &Fb, arraySize, "Fb");
+  MATRIX_INIT(Fm, arraySize, last_arraySize, "Fm");
+  //InitLDoublesMatrix( &Fm, arraySize, "Fm");
 
   etaN = (int**) malloc( arraySize*sizeof( int*));
   InitEtaN( etaN, nicks, seqlength);
@@ -170,8 +185,10 @@
   minILoopEnergyBySize = (DBL_TYPE*) malloc( seqlength*sizeof( DBL_TYPE));
 
   if( complexity == 3) {
-   InitLDoublesMatrix( &Fs, arraySize, "Fs");
-   InitLDoublesMatrix( &Fms, arraySize, "Fms");
+   MATRIX_INIT(Fs, arraySize, last_arraySize, "Fs");
+   //InitLDoublesMatrix( &Fs, arraySize, "Fs");
+   MATRIX_INIT(Fms, arraySize, last_arraySize, "Fms");
+   //InitLDoublesMatrix( &Fms, arraySize, "Fms");
   }
 
   if( complexity >= 5) {
@@ -188,6 +205,8 @@
    }
   }
 
+  last_arraySize = arraySize;
+  
   //Initialization to NAD_INFINITY
 
   if( complexity >= 5) 
@@ -255,8 +274,10 @@
        // Exactly 1 bp
        
        if( complexity == 3) {
-         if( etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] == 0 &&
-            etaN[ EtaNIndex(j-0.5, j-0.5, seqlength)][0] == 0) {
+         //if( etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] == 0 &&
+         //   etaN[ EtaNIndex(j-0.5, j-0.5, seqlength)][0] == 0) {
+         if( etaN[ pf_index(IDX(i), IDX(i), seqlength)][0] == 0 &&
+            etaN[ pf_index(IDX(j-1), IDX(j-1), seqlength)][0] == 0) {
               //regular multiloop.  No top-level nicks
               
               tempMin = MinMultiloops(i, j, seq, Fms, Fm,
@@ -264,7 +285,8 @@
               min_energy = MIN( tempMin, min_energy);
             }
          
-         if( etaN[ EtaNIndex(i+0.5, j-0.5, seqlength)][0] >= 1) {
+         //if( etaN[ EtaNIndex(i+0.5, j-0.5, seqlength)][0] >= 1) {
+         if( etaN[ pf_index(IDX(i), IDX(j-1), seqlength)][0] >= 1) {
            //Exterior loop (created by nick)
            tempMin = MinExteriorLoop( i, j, seq, seqlength, 
                                      F, nicks, etaN); 
@@ -474,20 +496,22 @@
   seq = foldparens = NULL;
 
 
+/*
   free( F);
   free( Fb);
   free( Fm);
 
   F = Fb = Fm = NULL;
+*/
 
   if(complexity == 3) {
-   free( Fs);
-   free( Fms);
+   // free( Fs);
+   // free( Fms);
    free( Fx);
    free( Fx_1);
    free( Fx_2);
    
-   Fs = Fms = Fx = Fx_1 = Fx_2 = NULL;
+   /* Fs = Fms = */ Fx = Fx_1 = Fx_2 = NULL;
   }
 
     if( complexity  >= 5) {
@@ -515,17 +539,28 @@
     }
   }
 
+/*
   for( i = 0; i <= seqlength-1; i++) {
     for( j = i-1; j <= seqlength-1; j++) {
       pf_ij = pf_index(i,j,seqlength);
       free( etaN[pf_ij]);
     }
   }
+*/
+  free( etaN[0] );
   free( etaN);
 
   free( maxILoopSize); maxILoopSize = NULL;
   free( minILoopEnergyBySize); minILoopEnergyBySize = NULL;
 
+  if (0) {
+    struct timeval stop;
+    gettimeofday(&stop, NULL);
+    float elapsed = (stop.tv_sec - start.tv_sec) * 1000.0f + (stop.tv_usec - start.tv_usec) / 1000.0f;
+    char txt[100];
+    sprintf(txt, "%7.2f", elapsed);
+    TraceJS(txt);
+  }
 
   return result;
 }
diff -ur -X .gitignore nupack3.0.4_stock/src/thermo/utils/min.c nupack3.0.4/src/thermo/utils/min.c
--- nupack3.0.4_stock/src/thermo/utils/min.c	2019-11-23 17:28:53.659132800 -0500
+++ nupack3.0.4/src/thermo/utils/min.c	2019-11-23 15:35:11.851468800 -0500
@@ -24,7 +24,8 @@
   int nNicks = 0;
 	
 	
-  index = EtaNIndex(i+0.5, j-0.5, seqlength);
+  //index = EtaNIndex(i+0.5, j-0.5, seqlength);
+  index = pf_index(IDX(i), IDX(j-1), seqlength);
   nNicks = etaN[ index][0];
 	
 	
@@ -48,8 +49,8 @@
   // Decomposes the region inside pair i,j into multiloops, i.e.
   // and excludes the possibility of "top level" nicks
 	
-  DBL_TYPE min_energy = 0.0;
-  DBL_TYPE bp_penalty = 0.0;
+  DBL_TYPE min_energy;
+  DBL_TYPE bp_penalty;
   DBL_TYPE extraTerms;
   DBL_TYPE tempMin;
 	
@@ -58,10 +59,11 @@
   min_energy = NAD_INFINITY;
   if( ( seq[i]) + ( seq[j]) == 5) {
     for( d = i+3; d <= j - 2; d++) {
-      //reset loop parameters
-      bp_penalty = 0.0;
       
-      if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0 ) {
+      //if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0 ) {
+      if( etaN[ pf_index( IDX(d-1), IDX(d-1), seqlength)][0] == 0 ) {
+        //reset loop parameters
+        bp_penalty = 0.0;
 				
 	if( seq[i] != BASE_C  && seq[j] != BASE_C) {
 	  bp_penalty += AT_PENALTY;
@@ -88,7 +90,7 @@
 	
   DBL_TYPE min_energy = NAD_INFINITY;
   DBL_TYPE tempMin;
-  DBL_TYPE bp_penalty = 0.0;
+  DBL_TYPE bp_penalty;
   int multiNick = -1;
   int index_ij;
   int leftIndex;
@@ -98,13 +100,16 @@
 	
   DBL_TYPE extraTerms;
 	
-  index_ij = EtaNIndex(i+0.5, j-0.5, seqlength);
+  //index_ij = EtaNIndex(i+0.5, j-0.5, seqlength);
+  index_ij = pf_index(IDX(i), IDX(j-1), seqlength);
   
   iNicked = jNicked = FALSE;
-  if( etaN[ EtaNIndex(j-0.5, j-0.5, seqlength)][0] != 0) {
+  //if( etaN[ EtaNIndex(j-0.5, j-0.5, seqlength)][0] != 0) {
+  if( etaN[ pf_index(IDX(j-1), IDX(j-1), seqlength)][0] != 0) {
     jNicked = TRUE;
   }
-  if( etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] != 0) {
+  //if( etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] != 0) {
+  if( etaN[ pf_index(IDX(i), IDX(i), seqlength)][0] != 0) {
     iNicked = TRUE;
   }
 	
@@ -158,8 +163,10 @@
 		
   int isEndNicked = FALSE;
 	
-  if( etaN[ EtaNIndex( i-0.5,i-0.5,seqlength)][0] == 1 || 
-      etaN[ EtaNIndex( j+0.5,j+0.5,seqlength)][0] == 1) 
+  //if( etaN[ EtaNIndex( i-0.5,i-0.5,seqlength)][0] == 1 || 
+  //    etaN[ EtaNIndex( j+0.5,j+0.5,seqlength)][0] == 1) 
+  if( etaN[ pf_index( IDX(i-1),IDX(i-1),seqlength)][0] == 1 || 
+      etaN[ pf_index( IDX(j),IDX(j),seqlength)][0] == 1) 
     isEndNicked = TRUE;
 	
   if( L >= 12) {
@@ -167,12 +174,12 @@
   }
 	
   //Use extensible cases              
-  if( CanPair( seq[ i], seq[j]) == TRUE) {
-    for( size = 8; size <= L - 4; size++) {
-			
+  if( CanPair( seq[ i], seq[j]) == TRUE && L >= 12) {
       extraTerms = InteriorMM( seq[i], seq[j], seq[i+1], 
-			       seq[j-1]);
+                               seq[j-1]);
       
+    for( size = 8; size <= L - 4; size++) {
+			
       tempMin = 
 	Fx[ fbixIndex( j-i, i, size, seqlength)] +
 	extraTerms;
@@ -211,14 +218,17 @@
   //Case 1:  L1 = 4, L2 >= 4;
   L1 = 4;
   d = i + L1 + 1;
+  if (etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0)
   for( L2 = 4; L2 <= j - d - 2; L2++) {
-    size = L1 + L2;
     e = j - L2 - 1;
     
     if( CanPair( seq[d], seq[e]) == TRUE &&
-	(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
-	(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	//(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
+	//(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	//(etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0) &&
+	(etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0) ) {
 			
+      size = L1 + L2;
       energy = asymmetryEfn( L1, L2, size) + InteriorMM( seq[e], seq[d], seq[e+1], seq[d-1]);
       /*Exclude the i-j stacking energy here, just in case i-j 
 	don't pair */
@@ -233,14 +243,17 @@
   //Case 2  L1 > 4, L2 = 4
   L2 = 4;
   e = j - L2 -1;
+  if (etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0)
   for( L1 = 5; L1 <= e-i-2; L1++) {   
-    size = L1 + L2;
     d = i + L1 + 1;
     
     if( CanPair( seq[d], seq[e]) == TRUE &&
-	(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
-	(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	//(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
+	//(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	//(etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0) &&
+	(etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0) ) {
 			
+      size = L1 + L2;
       energy = asymmetryEfn( L1, L2, size) + InteriorMM( seq[e], seq[d], seq[e+1], seq[d-1]);
       /*Exclude the i-j stacking energy here, just in case i-j 
 	don't pair */
@@ -285,6 +298,8 @@
 	
 }
 
+int (*binding_cb)(int i, int j, int* d, int*e) = NULL;
+
 /* ****************** */
 DBL_TYPE MinInextensibleIL( int i, int j, int seq[], int seqlength, 
 			    DBL_TYPE Fb[], int **etaN, DBL_TYPE *minILoopEnergyBySize) {
@@ -305,14 +320,17 @@
   
   for( L1 = 0; L1 <= 3; L1++) {
     d = i + L1 + 1;
+    if (etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] != 0) continue;
     for( L2 = 0; L2 <= MIN( 3, j-d-2); L2++) {
       e = j - L2 - 1;
-      size = L1 + L2;
 			
       if( CanPair( seq[d], seq[e]) == TRUE &&
-	  (etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
-	  (etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  //(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
+	  //(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  //(etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0) &&
+	  (etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0) ) {
 				
+        size = L1 + L2;
 	energy = InteriorEnergy( i, j, d, e, seq);
 				
 	tempMin = energy + 
@@ -327,15 +345,18 @@
   // Case 2a  L1 = 0,1,2,3, L2 >= 4;
   for( L1 = 0; L1 <= 3; L1++) {
     d = i + L1 + 1;
+    if (etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] != 0) continue;
     for( L2 = 4; L2 <= j - d - 2; L2++) {
       e = j - L2 - 1;
-      size = L1 + L2;
 
       if( CanPair( seq[d], seq[e]) == TRUE &&
-	  (etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
-	  (etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  //(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
+	  //(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  //(etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0) &&
+	  (etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0) ) {
 				
 				
+        size = L1 + L2;
 	energy = InteriorEnergy( i, j, d, e, seq);	
 				
 	tempMin = energy +
@@ -349,14 +370,17 @@
   // Case 2b L1 >= 4, L2 = 0,1,2,3;
   for( L2 = 0; L2 <= 3; L2++) {
     e = j - L2 - 1;
+    if (etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] != 0) continue;
     for( L1 = 4;  L1 <= e - i - 2; L1++) {
       d = i + L1 + 1;
-      size = L1 + L2;
 			
       if( CanPair( seq[d], seq[e]) == TRUE &&
-	  (etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
-	  (etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  //(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
+	  //(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  //(etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0) &&
+	  (etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0) ) {
 				
+        size = L1 + L2;
 	energy = InteriorEnergy( i, j, d, e, seq);
 	tempMin = energy + 
 	  Fb[ pf_index( d, e, seqlength)];
@@ -366,6 +390,26 @@
     }
   }    
 	
+  // EteRNA binding site hack
+  if (binding_cb != NULL) {
+    if ((*binding_cb)(i, j, &d, &e)) {
+      size = d - i + j - e;
+
+      if( CanPair( seq[d], seq[e]) == TRUE &&
+	  //(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
+	  //(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  (etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0) &&
+	  (etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0) ) {
+				
+	energy = InteriorEnergy( i, j, d, e, seq);
+	tempMin = energy + 
+	  Fb[ pf_index( d, e, seqlength)];
+	min_energy = MIN( min_energy, tempMin);
+	minILoopEnergyBySize[ size] = MIN( tempMin, minILoopEnergyBySize[size]);
+      }
+    }
+  }
+
   return min_energy;
 }
 
@@ -377,12 +421,13 @@
                   int *nicks, int **etaN) {
   
   int d; //base pair is i,d
-  DBL_TYPE bp_penalty = 0.0;
+  DBL_TYPE bp_penalty;
   int pf_ij = pf_index( i, j, seqlength);
   
   DBL_TYPE extraTerms;
   int nNicks;
-  int index_ij = EtaNIndex( i+0.5, j-0.5, seqlength);
+  //int index_ij = EtaNIndex( i+0.5, j-0.5, seqlength);
+  int index_ij = pf_index( IDX(i), IDX(j-1), seqlength);
   int start;
   DBL_TYPE tempMin;
   
@@ -395,11 +440,11 @@
   }
   
   for( d = start; d <= j; d++) {
-    bp_penalty = 0.0;
     
     if( CanPair( seq[i], seq[ d]) == TRUE &&
        ( seq[i]) + ( seq[d]) == 5) {
          
+         bp_penalty = 0.0;
          if( seq[i] != BASE_C && seq[d] != BASE_C) {
            bp_penalty = AT_PENALTY;
          }
@@ -442,19 +487,22 @@
  F[ pf_ij] = NickedEmptyF( i, j, nicks, seq, seqlength, etaN);
  
  for( d = i; d <= j - 1; d++) {
-   if( etaN[ EtaNIndex(d-0.5, d-0.5, seqlength)][0] == 0 || d == i ) {
+   //if( etaN[ EtaNIndex(d-0.5, d-0.5, seqlength)][0] == 0 || d == i ) {
+   if( etaN[ pf_index(IDX(d-1), IDX(d-1), seqlength)][0] == 0 || d == i ) {
      
      tempMin = F[ pf_index(i, d-1, seqlength)] + Fs[ pf_index( d, j, seqlength)];
      F[ pf_ij] = MIN( tempMin, F[ pf_ij]);
      
-     extraTerms = DangleEnergy( i, d-1, seq, seqlength) +
-       (ALPHA_3)*(d-i);
      
-     
-     if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0) { 
+     //if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0) { 
+     if( etaN[ pf_index( IDX(d-1), IDX(d-1), seqlength)][0] == 0) { 
        //otherwise Qm not possible
        
-       if( etaN[ EtaNIndex(i+0.5, d-0.5, seqlength)][0] == 0 ) {
+       //if( etaN[ EtaNIndex(i+0.5, d-0.5, seqlength)][0] == 0 ) {
+       if( etaN[ pf_index(IDX(i), IDX(d-1), seqlength)][0] == 0 ) {
+         extraTerms = DangleEnergy( i, d-1, seq, seqlength) +
+           (ALPHA_3)*(d-i);
+     
          tempMin = Fms[ pf_index( d, j, seqlength)] +
            extraTerms;
          Fm[ pf_ij] = MIN( tempMin, Fm[ pf_ij]);
@@ -484,28 +532,36 @@
   DBL_TYPE min_energy = NAD_INFINITY;
   DBL_TYPE tempMin;
   int d, e; // d - e is internal basepair 
-  DBL_TYPE bp_penalty = 0;
+  DBL_TYPE bp_penalty;
 	
 	
   for( d = i+1; d <= j - 5; d++) {
+    int eta_id = etaN[ pf_index(IDX(i), IDX(d-1), seqlength)][0];
+    int eta_dd = etaN[ pf_index(IDX(d-1), IDX(d-1), seqlength)][0];
+    int eta_ii = etaN[ pf_index(IDX(i), IDX(i), seqlength)][0];
+    if (eta_id != 0 && (eta_dd != 0 || eta_ii != 0)) continue;
     for( e = d + 4; e <= j - 1; e++) {
       if( CanPair( seq[d], seq[e]) == TRUE) {
-        bp_penalty = 0.0;
 				
-	if( etaN[ EtaNIndex(e+0.5, j-0.5, seqlength)][0] == 0) {
+	//if( etaN[ EtaNIndex(e+0.5, j-0.5, seqlength)][0] == 0) {
+	if( etaN[ pf_index(IDX(e), IDX(j-1), seqlength)][0] == 0) {
 				
-	  if( etaN[ EtaNIndex(i+0.5, d-0.5, seqlength)][0] == 0) {
+	  //if( etaN[ EtaNIndex(i+0.5, d-0.5, seqlength)][0] == 0) {
+	  if( eta_id == 0) {
 	    tempMin = InteriorEnergy( i, j, d, e, seq) +
 	      Fb[ pf_index( d, e, seqlength) ];
 					
 	    min_energy = MIN( tempMin, min_energy);
 	  }
 					
-	  if( etaN[ EtaNIndex(d-0.5, d-0.5, seqlength)][0] == 0 &&
-	      etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] == 0 &&
+	  //if( etaN[ EtaNIndex(d-0.5, d-0.5, seqlength)][0] == 0 &&
+	  //    etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] == 0 &&
+	  if( eta_dd == 0 &&
+	      eta_ii == 0 &&
 	      d>= i+6 && ( seq[d]) + ( seq[e]) == 5 &&
 	      ( seq[i]) + ( seq[j]) == 5 ) {
 						
+            bp_penalty = 0.0;
 	    if( seq[d] != BASE_C && seq[e] != BASE_C) {
 	      bp_penalty = AT_PENALTY;
 	    }
diff -ur -X .gitignore nupack3.0.4_stock/src/thermo/utils/nsStar.c nupack3.0.4/src/thermo/utils/nsStar.c
--- nupack3.0.4_stock/src/thermo/utils/nsStar.c	2019-11-23 17:28:53.661130000 -0500
+++ nupack3.0.4/src/thermo/utils/nsStar.c	2019-11-23 15:35:11.854460500 -0500
@@ -10,7 +10,7 @@
 
 #include <stdio.h>
 #include <stdlib.h>
-#include <memory.h>
+//#include <memory.h>
 #include <math.h>
 #include <string.h>
 #include <ctype.h>
diff -ur -X .gitignore nupack3.0.4_stock/src/thermo/utils/pairsPr.c nupack3.0.4/src/thermo/utils/pairsPr.c
--- nupack3.0.4_stock/src/thermo/utils/pairsPr.c	2019-11-23 17:28:53.664119900 -0500
+++ nupack3.0.4/src/thermo/utils/pairsPr.c	2019-11-23 15:35:11.859448300 -0500
@@ -64,7 +64,7 @@
 
   value = -b/a + 1.0;
 
-  precisionLost = (float) -1*log2l(value);
+  precisionLost = (float) -1*log(value)/log(2);
 
 #ifdef DEBUG
   if( a < 0) printf("%Le %Le %f\n", (long double) a, (long double) b, precisionLost);
diff -ur -X .gitignore nupack3.0.4_stock/src/thermo/utils/pfuncUtils.c nupack3.0.4/src/thermo/utils/pfuncUtils.c
--- nupack3.0.4_stock/src/thermo/utils/pfuncUtils.c	2019-11-23 17:28:53.675090100 -0500
+++ nupack3.0.4/src/thermo/utils/pfuncUtils.c	2019-11-23 15:35:11.863463100 -0500
@@ -9,7 +9,7 @@
 #include <stdio.h>
 #include <math.h>
 #include <stdlib.h>
-#include <memory.h>
+//#include <memory.h>
 #include <ctype.h>
 
 #include "pfuncUtilsHeader.h" //contains functions and structures
@@ -220,13 +220,28 @@
 
 /* *********************************************************** */ 
 int GetMismatchShift( int base1, int base2) {
+  static int shifts[64] = {
+    -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1,  0, -1, -1, -1,
+    -1, -1, -1,  1, -1, -1, -1, -1,
+    -1, -1,  2, -1,  4, -1, -1, -1,
+    -1,  3, -1,  5, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1
+  };
+  
+  return shifts[((base1 & 0x7) << 3) | (base2 & 0x7)];
+  
+}
+
+int GetMismatchShiftOld( int base1, int base2) {
   /* base1 and base2 are basepaired. the returned value is needed to 
   index energy arrays
   */
   int shift;
   
-  if( base1 == BASE_A) { /* this is for retrieving 
-  proper mismatch energy */
+  if( base1 == BASE_A) { /* this is for retrieving proper mismatch energy */
     shift = 0;
   }
   else if( base1 == BASE_C) {
@@ -253,7 +268,11 @@
 }
 
 /* ************************************************** */
-int GetPairType( int b) { //assume pair of b is the watson crick pair
+int GetPairType(int b) {
+  return b >= BASE_A && b <= BASE_T ? b-1: -1;
+}
+
+int GetPairTypeOld( int b) { //assume pair of b is the watson crick pair
   int shift;
   
   if( b == BASE_A) { 
diff -ur -X .gitignore nupack3.0.4_stock/src/thermo/utils/pfuncUtilsConstants.h nupack3.0.4/src/thermo/utils/pfuncUtilsConstants.h
--- nupack3.0.4_stock/src/thermo/utils/pfuncUtilsConstants.h	2019-11-23 17:28:53.667112300 -0500
+++ nupack3.0.4/src/thermo/utils/pfuncUtilsConstants.h	2019-11-23 15:35:11.865431200 -0500
@@ -34,7 +34,7 @@
 #endif
 
 
-
+#define USE_DOUBLE
 //sets the type of floating point variables
 #ifdef USE_DOUBLE
 
@@ -60,10 +60,10 @@
 #define MAXPRECERR 24 //max error in bits of precision
 
 //Maximum seqeuence length
-#define MAXSEQLENGTH 10000
+#define MAXSEQLENGTH 1000
 
 //maximum # of strands in a complex
-#define MAXSTRANDS 2000
+#define MAXSTRANDS 20
  
 //MATCH_PF will make the energy model used in energy calculations
 //match the one used in mfe and partition function calculations.
diff -ur -X .gitignore nupack3.0.4_stock/src/thermo/utils/pfuncUtilsHeader.h nupack3.0.4/src/thermo/utils/pfuncUtilsHeader.h
--- nupack3.0.4_stock/src/thermo/utils/pfuncUtilsHeader.h	2019-11-23 17:28:53.678083900 -0500
+++ nupack3.0.4/src/thermo/utils/pfuncUtilsHeader.h	2019-11-23 15:35:11.869239300 -0500
@@ -22,7 +22,7 @@
 #include "pfuncUtilsConstants.h"
 #include "runtime_constants.h"
 #include "physical_constants.h"
-#include "../../shared/utilsHeader.h"
+#include "utilsHeader.h"
 
 /* ************************ */
 // Macros
@@ -326,10 +326,11 @@
 /* ******************************************************************************** */
 //pf_index calculates the array index for a Q-type array
 int pf_index_old( int i, int j, int N);
-#define pf_index(i,j,N) ((j)==(i)-1?(N)*((N)+1)/2 + (i) : ((i)*(N)+(j)-(i)*(1+(i))/2))
-#define pf_index_same(i,N) ((i)*(N)-(i)*((i)-1)/2)
+#define pf_index(i,j,N) ((j)==(i)-1?(((N)*((N)+1))>>1) + (i) : ((i)*(N)+(j)-(((i)*(1+(i)))>>1)))
+#define pf_index_same(i,N) ((i)*(N)-(((i)*((i)-1))>>1))
 #define EtaNIndex(i,j,N) pf_index((int)(i),(int)(j),N)
 #define EtaNIndex_same(i,N) pf_index_same((int)(i),N)
+#define IDX(a) ((a)<0?0:(a))
 //((int)(j)==(int)(i)-1?(int)((N)*((N)+1)/2 + (int)(i)) : ((int)(i)*(N)+(j)-(i)*(1+(i))/2))
 //gap_index calculates the array index of a "gap" matrix.
 int gap_index( int h, int r, int m, int s, int seqlength);
